# 轻屿记前端联调代码修改准备书 (更新版)

## 📋 API功能覆盖完整性确认 - 基于最新文档

经过详细分析，**最新API文档已经100%覆盖了前端应用的所有功能需求**，并新增了**增强型下载功能**：

### ✅ 功能覆盖分析
1. **认证系统** - 完整覆盖（包括设置页面的密码修改和头像重置）
2. **文件管理** - 完整覆盖（现有多选UI已就绪，只需API对接）
3. **🆕 增强下载** - 新增文件夹清单和批量下载功能
4. **音乐播放** - 完整覆盖（聚合查询设计优秀）
5. **文档管理** - 完整覆盖（支持多格式和MD编辑）
6. **传输管理** - 完整覆盖（异步上传和实时状态更新）
7. **专注岛屿** - 完整覆盖（统计和收集功能齐全）
8. **分享功能** - 完整覆盖（设置页面已有分享管理UI）
9. **回收站** - 完整覆盖（页面已有对应操作按钮）

---

## 🎯 核心修改策略（更新版）

### 1. API路径统一原则
- **统一前缀**：所有API使用 `/v1` 前缀
- **响应格式**：统一处理 `{code, message, data}` 结构
- **命名转换**：snake_case ↔ camelCase 自动转换

### 2. 新增下载增强功能
- **文件夹清单获取** - 支持递归获取目录结构
- **批量下载清单** - 多选文件/文件夹的统一下载
- **下载进度管理** - 基于清单的精确进度显示

### 3. 现有优势保持
- **多选功能已完整** - DrivePage中的 `selectedItemIds` 已实现
- **批量操作UI就绪** - 右键菜单已支持批量操作显示
- **WebSocket基础** - 只需添加连接和事件监听

---

## 📁 详细修改计划

## 一、HTTP 基础层重构 - `src/utils/http.ts`

### 🔄 基础配置修改 (保持不变)

```typescript
// 1. 修改baseURL配置
const http: AxiosInstance = axios.create({
  baseURL: import.meta.env.PROD ? '/api/v1' : 'http://localhost:8080/api/v1',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 2. 响应拦截器 - 处理统一响应格式
http.interceptors.response.use(
  (response: AxiosResponse) => {
    const { code, message, data } = response.data
    if (code === 200 || code === 202) {
      return { ...response, data: { code, message, data } }
    } else {
      throw new Error(message || '请求失败')
    }
  },
  // 现有错误处理逻辑保持不变...
)
```

### 🆕 增强下载API（重要更新）

```typescript
// 新增：下载相关API（基于最新文档）
export const downloadAPI = {
  // 获取单个文件下载链接（保持不变）
  getFileDownloadUrl: (fileId: number) => {
    return get(`/download/file/${fileId}`)
  },
  
  // ✨ 新增：获取文件夹内容清单（递归）
  getFolderManifest: (folderId: number) => {
    return get(`/folders/${folderId}/manifest`)
  },
  
  // ✨ 新增：获取批量选择的下载清单
  getBatchManifest: (data: { file_ids?: number[]; folder_ids?: number[] }) => {
    return post('/items/manifest', data)
  }
}
```

### 🔄 传输API更新（支持新的下载流程）

```typescript
export const transferAPI = {
  // 文件上传（保持不变）
  uploadFile: (file: File, folderId?: number, onProgress?: (progress: number) => void) => {
    const formData = new FormData()
    formData.append('file', file)
    if (folderId) formData.append('folder_id', folderId.toString())
    
    return post('/upload', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total)
          onProgress(progress)
        }
      }
    })
  },
  
  // ✨ 重构：获取下载链接 - 支持新的清单模式
  getDownloadInfo: async (selection: { fileIds?: number[]; folderIds?: number[] }) => {
    const { fileIds = [], folderIds = [] } = selection
    
    // 如果只有一个文件，直接获取下载链接
    if (fileIds.length === 1 && folderIds.length === 0) {
      return downloadAPI.getFileDownloadUrl(fileIds[0])
    }
    
    // 否则获取批量清单
    return downloadAPI.getBatchManifest({
      file_ids: fileIds.length > 0 ? fileIds : undefined,
      folder_ids: folderIds.length > 0 ? folderIds : undefined
    })
  },
  
  // 获取传输摘要（保持不变）
  getTransferSummary: () => {
    return get('/transfers/summary')
  },
  
  // 获取传输历史（保持不变）
  getTransferHistory: (params?: { status?: string; page?: number; size?: number }) => {
    return get('/transfers', { params })
  },
  
  // 删除传输记录（保持不变）
  deleteTransferLog: (logId: number, deleteFile: boolean = false) => {
    return del(`/transfers/${logId}`, { params: { delete_file: deleteFile } })
  },
  
  // 清空已完成记录（保持不变）
  clearCompletedTransfers: () => {
    return del('/transfers/completed')
  }
}
```

---

## 二、新增下载管理Store - `src/store/DownloadStore.ts`

### 🆕 创建专门的下载管理Store

```typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { downloadAPI, transferAPI } from '../utils/http'

// 下载任务接口定义
interface DownloadTask {
  id: string
  name: string
  totalSize: number
  totalFiles: number
  downloadedSize: number
  downloadedFiles: number
  status: 'pending' | 'downloading' | 'completed' | 'failed' | 'paused'
  items: DownloadItem[]
  startTime?: Date
  endTime?: Date
  error?: string
}

interface DownloadItem {
  type: 'directory' | 'file'
  relativePath: string
  fileId?: number
  size?: number
  downloaded?: boolean
  downloadUrl?: string
}

export const useDownloadStore = defineStore('download', () => {
  // 状态
  const downloadTasks = ref<DownloadTask[]>([])
  const isDownloading = ref(false)
  
  // 计算属性
  const activeDownloads = computed(() => 
    downloadTasks.value.filter(task => task.status === 'downloading')
  )
  
  const completedDownloads = computed(() => 
    downloadTasks.value.filter(task => task.status === 'completed')
  )
  
  // ✨ 创建下载任务（支持新的清单API）
  const createDownloadTask = async (selection: {
    fileIds?: number[]
    folderIds?: number[]
    taskName?: string
  }): Promise<string> => {
    try {
      // 获取下载清单
      const response = await transferAPI.getDownloadInfo({
        fileIds: selection.fileIds,
        folderIds: selection.folderIds
      })
      
      const { data } = response.data
      
      // 创建下载任务
      const taskId = generateTaskId()
      const task: DownloadTask = {
        id: taskId,
        name: selection.taskName || `下载任务_${new Date().toLocaleString()}`,
        totalSize: data.total_size || 0,
        totalFiles: data.total_files || 0,
        downloadedSize: 0,
        downloadedFiles: 0,
        status: 'pending',
                 items: data.items?.map(item => ({
           type: item.type,
           relativePath: item.relative_path,
           fileId: item.file_id,
           size: item.size,
           downloaded: false
         })) || [],
        startTime: new Date()
      }
      
      downloadTasks.value.push(task)
      return taskId
    } catch (error) {
      console.error('创建下载任务失败:', error)
      throw error
    }
  }
  
  // ✨ 开始下载任务（基于清单逐文件下载）
  const startDownload = async (taskId: string): Promise<void> => {
    const task = downloadTasks.value.find(t => t.id === taskId)
    if (!task) return
    
    task.status = 'downloading'
    isDownloading.value = true
    
    try {
      // 过滤出需要下载的文件
      const filesToDownload = task.items.filter(item => item.type === 'file')
      
      for (const fileItem of filesToDownload) {
        if (task.status !== 'downloading') break // 支持暂停
        
        await downloadSingleFile(task, fileItem)
        task.downloadedFiles++
      }
      
      task.status = 'completed'
      task.endTime = new Date()
    } catch (error) {
      task.status = 'failed'
      task.error = error.message || '下载失败'
      console.error('下载任务失败:', error)
    } finally {
      isDownloading.value = activeDownloads.value.length > 0
    }
  }
  
  // 下载单个文件
  const downloadSingleFile = async (task: DownloadTask, fileItem: DownloadItem): Promise<void> => {
    if (!fileItem.fileId) return
    
    try {
      // 获取文件下载链接
      const response = await downloadAPI.getFileDownloadUrl(fileItem.fileId)
      const downloadInfo = response.data.data[0]
      
             // 使用Electron的下载API或浏览器下载
       if (window.electronAPI) {
         // Electron环境下的下载
         await window.electronAPI.downloadFile({
           url: downloadInfo.download_url,
           filePath: fileItem.relativePath,
           expectedSize: fileItem.size
         })
       } else {
        // 浏览器环境下的下载（降级方案）
        const link = document.createElement('a')
        link.href = downloadInfo.download_url
        link.download = fileItem.relativePath.split('/').pop() || 'download'
        document.body.appendChild(link)
        link.click()
        document.body.removeChild(link)
      }
      
      fileItem.downloaded = true
      task.downloadedSize += fileItem.size || 0
    } catch (error) {
      console.error(`文件下载失败: ${fileItem.relativePath}`, error)
      throw error
    }
  }
  
  // 暂停下载
  const pauseDownload = (taskId: string): void => {
    const task = downloadTasks.value.find(t => t.id === taskId)
    if (task && task.status === 'downloading') {
      task.status = 'paused'
    }
  }
  
  // 恢复下载
  const resumeDownload = (taskId: string): Promise<void> => {
    return startDownload(taskId)
  }
  
  // 删除下载任务
  const removeDownloadTask = (taskId: string): void => {
    const index = downloadTasks.value.findIndex(t => t.id === taskId)
    if (index !== -1) {
      downloadTasks.value.splice(index, 1)
    }
  }
  
  // 工具函数
  const generateTaskId = (): string => {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
  
  return {
    // 状态
    downloadTasks,
    isDownloading,
    
    // 计算属性
    activeDownloads,
    completedDownloads,
    
    // 方法
    createDownloadTask,
    startDownload,
    pauseDownload,
    resumeDownload,
    removeDownloadTask
  }
})
```

---

## 三、DriveStore 调整 - `src/store/DriveStore.ts`

### 🔄 集成新的下载功能

```typescript
// 在现有DriveStore中新增下载相关方法

import { useDownloadStore } from './DownloadStore'

// 在DriveStore内部添加以下方法：

// ✨ 批量下载选中项目（对应现有的下载按钮）
const batchDownloadItems = async () => {
  if (selectedItemIds.value.size === 0) return
  
  const downloadStore = useDownloadStore()
  const fileIds: number[] = []
  const folderIds: number[] = []
  
  // 从selectedItemIds中分离文件和文件夹
  selectedItemIds.value.forEach(id => {
    const item = findItemById(id)
    if (item?.type === 'folder') {
      folderIds.push(id)
    } else {
      fileIds.push(id)
    }
  })
  
  try {
    // 创建下载任务
    const taskId = await downloadStore.createDownloadTask({
      fileIds: fileIds.length > 0 ? fileIds : undefined,
      folderIds: folderIds.length > 0 ? folderIds : undefined,
      taskName: `批量下载_${selectedItemIds.value.size}项`
    })
    
    // 开始下载
    await downloadStore.startDownload(taskId)
    
    // 清除选中状态
    selectedItemIds.value.clear()
    
    // 提示用户
    console.log(`已开始下载任务: ${taskId}`)
  } catch (error) {
    console.error('批量下载失败:', error)
    throw error
  }
}

// ✨ 单个项目下载（对应右键菜单下载）
const downloadSingleItem = async (itemId: number, itemType: 'file' | 'folder') => {
  const downloadStore = useDownloadStore()
  
  try {
    const taskId = await downloadStore.createDownloadTask({
      fileIds: itemType === 'file' ? [itemId] : undefined,
      folderIds: itemType === 'folder' ? [itemId] : undefined,
      taskName: `下载_${findItemById(itemId)?.name || 'unknown'}`
    })
    
    await downloadStore.startDownload(taskId)
  } catch (error) {
    console.error('单项下载失败:', error)
    throw error
  }
}
```

---

## 四、新增类型定义 - `src/types/api.d.ts`

### 🆕 下载相关类型定义

```typescript
// 新增：下载清单相关类型
export interface FolderManifestResponse {
  root_folder_name: string
  total_size: number
  total_files: number
  items: ManifestItem[]
}

export interface BatchManifestResponse {
  total_size: number
  total_files: number
  items: ManifestItem[]
}

export interface ManifestItem {
  type: 'directory' | 'file'
  relative_path: string
  file_id?: number
  size?: number
}

// 原有类型定义保持不变...
export interface ApiResponse<T = any> {
  code: number
  message: string
  data: T
}

export interface PageResponse<T> {
  total: number
  current_page: number
  page_size: number
  records: T[]
}
```

---

## 五、页面组件调整

### 🔄 云盘页面 - `src/pages/DrivePage.vue`

#### 🆕 集成新的下载功能

```typescript
// 在现有的DrivePage.vue中添加下载相关方法

import { useDownloadStore } from '../store/DownloadStore'

const downloadStore = useDownloadStore()

// ✨ 批量下载（对应现有的下载按钮）
const handleBatchDownload = async () => {
  if (selectedItemIds.value.size === 0) return
  
  try {
    await driveStore.batchDownloadItems()
    toast.success(`已开始下载 ${selectedItemIds.value.size} 个项目`)
  } catch (error) {
    toast.error('下载失败')
  }
}

// ✨ 右键菜单下载
const handleContextDownload = async (item: DriveItem) => {
  try {
    await driveStore.downloadSingleItem(item.id, item.type === 'folder' ? 'folder' : 'file')
    toast.success(`已开始下载 ${item.name}`)
  } catch (error) {
    toast.error('下载失败')
  }
}

// 现有的批量操作保持不变...
const handleBatchDelete = async () => {
  // ... 现有逻辑
}

const handleBatchMove = async (targetFolderId: number) => {
  // ... 现有逻辑
}
```

### 🆕 下载管理页面组件 - `src/components/DownloadManager.vue`

```vue
<template>
  <div class="download-manager">
    <div class="download-header">
      <h3>下载管理</h3>
      <div class="download-stats">
        <span>活跃: {{ activeDownloads.length }}</span>
        <span>已完成: {{ completedDownloads.length }}</span>
      </div>
    </div>
    
    <div class="download-list">
      <div 
        v-for="task in downloadTasks" 
        :key="task.id"
        class="download-task"
        :class="task.status"
      >
        <div class="task-info">
          <div class="task-name">{{ task.name }}</div>
          <div class="task-progress">
            <div class="progress-bar">
              <div 
                class="progress-fill"
                :style="{ width: `${(task.downloadedFiles / task.totalFiles) * 100}%` }"
              ></div>
            </div>
            <span class="progress-text">
              {{ task.downloadedFiles }}/{{ task.totalFiles }} 文件
              ({{ formatBytes(task.downloadedSize) }}/{{ formatBytes(task.totalSize) }})
            </span>
          </div>
        </div>
        
        <div class="task-actions">
          <button 
            v-if="task.status === 'downloading'"
            @click="downloadStore.pauseDownload(task.id)"
            class="btn-pause"
          >
            暂停
          </button>
          <button 
            v-else-if="task.status === 'paused'"
            @click="downloadStore.resumeDownload(task.id)"
            class="btn-resume"
          >
            继续
          </button>
          <button 
            v-if="task.status === 'completed' || task.status === 'failed'"
            @click="downloadStore.removeDownloadTask(task.id)"
            class="btn-remove"
          >
            移除
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { useDownloadStore } from '../store/DownloadStore'

const downloadStore = useDownloadStore()
const { downloadTasks, activeDownloads, completedDownloads } = storeToRefs(downloadStore)

const formatBytes = (bytes: number): string => {
  if (bytes === 0) return '0 B'
  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}
</script>
```

---

## 📋 实施检查清单（更新版）

### 立即修改的文件：

#### 核心API层
- [ ] `src/utils/http.ts` - 新增下载清单API
- [ ] `src/types/api.d.ts` - 新增下载相关类型定义

#### Store层
- [ ] **🆕 `src/store/DownloadStore.ts`** - 创建下载管理Store
- [ ] `src/store/DriveStore.ts` - 集成下载功能方法
- [ ] `src/store/AuthStore.ts` - 适配新认证接口（保持不变）
- [ ] `src/store/MusicStore.ts` - 接入音乐API（保持不变）

#### 组件层
- [ ] **🆕 `src/components/DownloadManager.vue`** - 创建下载管理组件
- [ ] `src/pages/DrivePage.vue` - 集成新下载功能
- [ ] `src/pages/SettingsPage.vue` - 接入密码和头像API（保持不变）

#### 系统层
- [ ] `src/utils/websocket.ts` - 新增WebSocket管理（保持不变）
- [ ] `src/App.vue` - 集成WebSocket（保持不变）

### 🆕 新增功能测试：

#### 下载功能验证
- [ ] 单文件下载链接获取
- [ ] 文件夹清单递归获取
- [ ] 批量选择下载清单生成
- [ ] 下载进度显示和管理
- [ ] 下载任务暂停/恢复/删除

#### 现有功能保持
- [ ] 认证流程（登录、注册、密码修改）
- [ ] 文件上传的异步处理和WebSocket更新
- [ ] 多选和批量操作（移动、删除）
- [ ] 音乐页面数据加载和播放
- [ ] 设置页面的各项功能
- [ ] 回收站操作
- [ ] 分享功能

---

## 🎯 预期效果（更新版）

完成以上修改后，除了原有的所有功能外，还将新增：

### 🆕 增强的下载体验
1. **智能下载管理** - 基于清单的精确进度显示
2. **文件夹下载** - 保持完整目录结构的批量下载
3. **多任务并行** - 支持多个下载任务同时进行
4. **断点续传基础** - 下载任务可暂停和恢复

### 保持的原有优势
1. **API完全对接** - 所有功能使用真实后端数据
2. **实时更新** - 文件处理状态通过WebSocket实时反馈
3. **批量操作完整** - 多选UI已就绪，API对接完成后即可使用
4. **数据一致性** - 音乐/文档页面数据与云盘保持同步
5. **用户体验优化** - 异步处理减少等待时间
6. **功能完整性** - 设置页面所有功能可用

**这个更新版修改计划在保持原有架构优势的基础上，大幅提升了下载体验，为用户提供更加完善的文件管理功能！** 